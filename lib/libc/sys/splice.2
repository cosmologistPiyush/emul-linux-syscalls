.\"	$NetBSD$
.\"
.\" Copyright (c) 1980, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)read.2	8.4 (Berkeley) 2/26/94
.\"
.Dd September 21, 2022
.Dt SPLICE 2
.Os
.Sh NAME
.Nm splice
.Nd transfer data between 2 descriptors inside the kernel space
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In splice.h
.Ft ssize_t
.Fo splice
.Fa "int fd_in"
.Fa "off_t *off_in"
.Fa "int fd_out"
.Fa "off_t *off_out"
.Fa "size_t nbytes"
.Fc
.Sh DESCRIPTION
.Fn splice
attempts to transfer
.Fa nbytes
of data from the object referenced by the descriptor
.Fa fd_in
to the object referenced by the descriptor
.Fa fd_out
without copying the data between the kernel and the user address
space.
.Pp
The following semantics apply for each descriptor and its corresponding offset:
.Pp
.Bl -hyphen -offset indent -compact
.It
.Fa fd_in
and
.Fa fd_out
can be either a regular file descriptor, a pipe descriptor, or a socket
descriptor.
.It
If
.Fa fd_in
or
.Fa fd_out
refers to a pipe or a socket descriptor, then their corresponding offset
.Fa off_in
or
.Fa off_out
must be NULL.
.It
If
.Fa fd_in
or
.Fa fd_out
refers to a regular file and
.Fa off_in
or
.Fa off_out
respectively is NULL, then data is read starting from the file offset, and the
value of file offset is modified.
.It
However, if the offset of the corresponding regular file descriptor is non-NULL,
data is read starting from the location specified by the offset variale with
future modifications to its value, and not the value of the file offset.
.El
.Pp
.Fn splice
is a general purpose call that moves data between two descriptors without
copying between the kernel and the user address space. It may be used as the
backing mechanism for implementing
.Fn
sendfile
and the Linux specific
.Fn
splice
in the compat_linux layer.
.\" More info about working of splice;
.Sh RETURN VALUES
If successful,
.Fn splice
returns the number of bytes moved from
.Fa fd_in
to
.Fa fd_out
Otherwise, \-1 is returned and the global variable
.Va errno
is set to indicate the error.
.Sh ERRORS
.Fn splice
will succeed unless:
.Bl -tag -width Er
.It Bq Er EAGAIN
The individual file descriptor
.Fa fd_in
or
.Fa fd_out
was marked for non-blocking I/O, and no data was ready to be read or written.
.It Bq Er EBADF
Either
.Fa fd_in
or
.Fa fd_out
is not a valid descriptor open for reading or writing respectively.
.\" space for EFAULT if it is a possibility
.It Bq Er EINTR
A read or write from or to a slow device
(i.e. one that might block for an arbitrary amount of time)
was interrupted by the delivery of a signal
before any data arrived.
See
.Xr sigaction 2
for more information on the interaction between signals and system
calls.
.It Bq Er EINVAL
Either file pointer associated with
.Fa fd_in
or
.Fa fd_out
was negative; or
the total length of the I/O is more than can be expressed by the size_t
return value.
.It Bq Er EIO
An I/O error occurred while reading from or writing to the file system.
.It Bq Er EISDIR
.Fa fd_in
refers to a directory.
.It Bq Er EFBIG
An attempt was made to write to
.Fa fd_out
that corresponds to a regular file which exceeds the process's file size limit
or the maximum file size.
.It Bq Er ENOSPC
There is no free space remaining on the file system
containing the out file referred to by
.Fa fd_out .
.It Bq Er EDQUOT
The user's quota of disk blocks on the file system
containing the out file referred to by
.Fa fd_out ,
has been exhausted.
.El
.Sh SEE ALSO
.Xr read 2 ,
.Xr write 2 ,
.Xr open 2 ,
.Xr pipe 2 ,
.Xr poll 2 ,
.Xr select 2 ,
.Xr sigaction 2 ,
.Xr socket 2
.Sh STANDARDS
The
.Fn splice
system call is not a part of any standard. It was originally a Linux-specific
call, however, that implementation requires at least one of the two descriptors
to be a pipe descriptor. The NetBSD implementation does not have any such
requirement. Its a general purpose call which can be used to back more system
calls of similar design \- where data needs to be moved between two file
descriptors without making copies between the kernel and the user address space.
.Sh CAVEATS
.Fn
splice
works by reading as much data possible in a kernel allocated buffer and then
tries to write it out. Naturally, the whole process is done inside loops in an
attempt to move all of the
.Fa nbytes
of data. However, if in an unlikely scenario, a signal occurs during the write
process, the system call returns with either a partial write or \-1, setting
errno to EINTR. In such a case, as there already was un\-written data, read
inside the kernel buffer, the file pointer or the
.Fa off_in
might not be in sync with the total bytes moved. For now this should be taken
care of by the user.
